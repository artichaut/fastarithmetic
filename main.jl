using Nemo

"""
    monomialToDual{T <: FieldElem}(a::Array{T,1},P::PolyElem{T})

Convert monomial (canonical) coordinates "a" to dual coordinates
with respect to the trace generated by P.

# Remark
* a and P are over a field k which must be a perfect field ;
* P must be monic and squarefree ;
* k[x]/(P) is not necessarily a field since P is not necessarily irreducible.
"""
function monomialToDual{T <: FieldElem}(a::Array{T,1},P::PolyElem{T})
  k::FqNmodFiniteField=parent(a[1])
  @assert k==base_ring(P)
  m::Int64=degree(P)
  R::FqNmodPolyRing=parent(P)
  t::PolyElem{T}=gen(R)
  S,x=PowerSeriesRing(k,m,"x")
  Q::PolyElem{T}=reverse(P,m+1)
  Q=gcdinv(Q,t^m)[2]
  A::PolyElem{T}=R(a)
  b::PolyElem{T}=(reverse((derivative(P)*A)%P,m)*Q)%(t^m)
  return T[coeff(b,i) for i in 0:(m-1)]
end

"""
    dualToMonomial{T}(b::Array{T,1},P::PolyElem{T})

Convert dual coordinates "b" to monomial coordinates with respect to the trace
generated by P.

# Remark
* a and P are over a field k which must be a perfect field ;
* P must be monic and squarefree ;
* k[x]/(P) is not necessarily a field since P is not necessarily irreducible.
"""
function dualToMonomial{T}(b::Array{T,1},P::PolyElem{T})
  k::FqNmodFiniteField=parent(b[1])
  @assert k==base_ring(P)
  m::Int64=degree(P)
  R::FqNmodPolyRing=parent(P)
  t::PolyElem{T}=gen(R)
  S::PolyElem{T}=gcdinv(derivative(P),P)[2]
  c::PolyElem{T}=(reverse(P,m+1)*R(b))%(t^m)
  c=reverse(c,m)
  d::PolyElem{T}=(c*S)%P
  return T[coeff(d,i) for i in 0:(m-1)]
end

"""
    mulT{T}(c::Array{T,1},P::PolyElem{T},n::Int64)

The tranposition of the algorithm of multiplication by P.

# Arguments
* c::Array{T,1} must have length m (degree of P) + n.

# Remark
* closely linked with the middle product [1] ;
* I don't really see why n is an argument, since we could obtain it by
computing n = length(c) - degree(P).

# References
* [1] : G. Hanrot, M. Quercia, and P. Zimmerman. The middle product algorithm I.
Appl. Algebra Engrg. Comm. Comput., 14(6):415-438, 2004.
"""
function mulT{T}(c::Array{T,1},P::PolyElem{T},n::Int64)
  m::Int64=degree(P)
  k::FqNmodFiniteField=base_ring(P)
  @assert k==parent(c[1])
  R::FqNmodPolyRing=parent(P)
  t::PolyElem{T}=gen(R)
  p::Array{T,1}=fq_nmod[k(coeff(P,j)) for j in 0:m]
  b::Array{T,1}=Array(fq_nmod,n+1) # array filled with "#undef"
  for i in 1:(n+1)
    b[i]=k(0)
  end
  for i in range(m+n,-1,m+n+1)
    for j in range(min(m,i),-1,min(m,i)-max(0,i-n)+1)
      b[i-j+1]=b[i-j+1]+p[j+1]*c[i+1]
    end
  end
  return R(fq_nmod[b[i] for i in 1:(n+1)])
end

"""
    remT{T}(r::Array{T,1},P::PolyElem{T},n::Int64)

Transposition of the remainder by P algorithm.

It's an other linear extension algorithm. Take the r first values of a linear
recurring sequence of minimal polynomial P and compute the n first values.
"""
function remT{T}(r::Array{T,1},P::PolyElem{T},n::Int64)
  m=degree(P)
  k=base_ring(P)
  @assert k==parent(r[1])
  K=parent(P)
  t=gen(K)
  R=K(fq_nmod[r[i] for i in 1:m])# useless creation of a list... memory !
  α=reverse(P,m+1)
  α=gcdinv(α,t^(n-m+1))[2]
  b=copy(r)
  while length(b)<(n+1)
    push!(b,k(0))
  end
  return R-(t^m)*((α*mulT(b,P,n-m))%(t^(n-m+1)))
end

k,u=FiniteField(1993,1,"u")
K,t=PolynomialRing(k,"t")
P=t^2-t-1
r=fq_nmod[k(1),k(1)]

remT(r,P,10)



"""
    remTnaif{T}(r::Array{T,1},P::PolyElem{T},n::Int64)

Linear extension algorithm.

Take the m first elements of a Linear recurring sequence with minimal
polynomial P and compute the n first.
"""
function remTnaif{T}(r::Array{T,1},P::PolyElem{T},n::Int64)
  m=degree(P)
  p=fq_nmod[coeff(P,j) for j in 0:m]
  b=copy(r)
  while length(b)<n
      s=sum([-1*p[j]*b[end-m+j] for j in 1:m])
      push!(b,p[end]^(-1)*s)
  end
  return b
end

function embed(b,P,c,Q,r=0)
  """
  Compute the embeding of Π={bc | b ∈ k[x]/(P) , c ∈ k[y]/(Q)} ⊂ k[x,y]/(P,Q)}.
  """
  if r==0
    r=length(b)*length(c)
  end
  t=remTnaif(b,P,r)
  u=remTnaif(c,Q,r)
  return fq_nmod[t[j]*u[j] for j in 1:r]
end

function berlekampMassey{T}(a::Array{T,1},n::Int64,S=0)
  if S==0
    k=parent(a[1])
    S,x=PolynomialRing(k,"x")
  else
    x=gen(S)
  end
  polyT=typeof(x)
  m::Int64=2*n-1
  R0::polyT=S(x^(2*n))
  R1::polyT=S(reverse(a))
  V0::polyT=S(0)
  V1::polyT=S(1)
  while n<=degree(R1)
    Q::polyT,R::polyT=divrem(R0,R1)
    V::polyT=V0-Q*V1
    V0=V1
    V1=V
    R0=R1
    R1=R
  end
  return V1*lead(V1)^(-1)
end

function computeR{polyT}(P::polyT,Q::polyT)
  m::Int64=degree(P)
  n::Int64=degree(Q)
  T=typeof(coeff(P,0))
  k=parent(coeff(P,0))

  vp::Array{T,1}=Array(T,m) # creation of the vector (1,0,...,0) (length m)
  vp[1]=k(1)
  for j in 2:m
    vp[j]=k(0)
  end

  vq::Array{T,1}=Array(T,n) # creation of the vector (1,0,...,0) (length n)
  vq[1]=k(1)
  for j in 2:n
    vq[j]=k(0)
  end

  up=monomialToDual(vp,P)
  uq=monomialToDual(vq,Q)

  t=embed(up,P,uq,Q,2*m*n)

  return berlekampMassey(t,m*n,parent(P))
end

function project(a::Array{fq_nmod,1},P::fq_nmod_poly,Q::fq_nmod_poly)
  n::Int64=degree(Q)
  m::Int64=degree(P)
  c::Array{fq_nmod,1}=Array(fq_nmod,n)
  k=parent(coeff(Q,0))
  c[1]=k(1)
  for j in 2:n
    c[j]=k(0)
  end
  u::Array{fq_nmod,1}=remTnaif(c,Q,m*n)
  println(u)
  K=parent(P)
  d=K([a[j]*u[j] for j in 1:(m*n)])%P
  return fq_nmod[coeff(d,j) for j in 0:(m-1)]
end

### ESPACE DE TESTS ###

k,u=FiniteField(5,1,"u")
T,t=PolynomialRing(k,"t")

P=t^3+t+1
Q=t^2+t+1

v=fq_nmod[k(4),k(1)]

dualToMonomial(monomialToDual(v,P),P)

parent(P)

R=computeR(P,Q)

R+P

uq=monomialToDual(fq_nmod[k(1),k(0)],Q)
up=monomialToDual(fq_nmod[k(1),k(0),k(0)],P)
a=embed(up,P,uq,Q)
aa=dualToMonomial(a,R)


project(aa,P,Q)


t=Array(fq_nmod,3)
typeof(t)
t[2]=k(2)

function test{T}(a::T,b::T)
  return T[a*b,a+b]
end


test(fmpz(2),fmpz(4))
