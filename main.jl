using Nemo

"""
    monomialToDual{T <: FieldElem}(a::Array{T,1},P::PolyElem{T})

Convert monomial (canonical) coordinates "a" to dual coordinates
with respect to the trace generated by P.

# Remark
* a and P are over a field k which must be a perfect field ;
* P must be monic and squarefree ;
* k[x]/(P) is not necessarily a field since P is not necessarily irreducible.
"""
function monomialToDual{T <: FieldElem}(a::Array{T,1},P::PolyElem{T})
  k::FqNmodFiniteField=parent(a[1])
  @assert k==base_ring(P)
  m::Int64=degree(P)
  R::FqNmodPolyRing=parent(P)
  t::PolyElem{T}=gen(R)
  S,x=PowerSeriesRing(k,m,"x")
  Q::PolyElem{T}=reverse(P,m+1)
  Q=gcdinv(Q,t^m)[2]
  A::PolyElem{T}=R(a)
  b::PolyElem{T}=(reverse((derivative(P)*A)%P,m)*Q)%(t^m)
  return T[coeff(b,i) for i in 0:(m-1)]
end

"""
    dualToMonomial{T}(b::Array{T,1},P::PolyElem{T})

Convert dual coordinates "b" to monomial coordinates with respect to the trace
generated by P.

# Remark
* a and P are over a field k which must be a perfect field ;
* P must be monic and squarefree ;
* k[x]/(P) is not necessarily a field since P is not necessarily irreducible.
"""
function dualToMonomial{T}(b::Array{T,1},P::PolyElem{T})
  k::FqNmodFiniteField=parent(b[1])
  @assert k==base_ring(P)
  m::Int64=degree(P)
  R::FqNmodPolyRing=parent(P)
  t::PolyElem{T}=gen(R)
  S::PolyElem{T}=gcdinv(derivative(P),P)[2]
  c::PolyElem{T}=(reverse(P,m+1)*R(b))%(t^m)
  c=reverse(c,m)
  d::PolyElem{T}=(c*S)%P
  return T[coeff(d,i) for i in 0:(m-1)]
end

"""
    mulT{T}(c::Array{T,1},P::PolyElem{T},n::Int64)

The tranposition of the algorithm of multiplication by P.

# Arguments
* c::Array{T,1} must have length m (degree of P) + n.

# Remark
* closely linked with the middle product [1] ;
* I don't really see why n is an argument, since we could obtain it by
computing n = length(c) - degree(P).

# References
* [1] : G. Hanrot, M. Quercia, and P. Zimmerman. The middle product algorithm I.
Appl. Algebra Engrg. Comm. Comput., 14(6):415-438, 2004.
"""
function mulT{T}(c::Array{T,1},P::PolyElem{T},n::Int64)
  m::Int64=degree(P)
  k::FqNmodFiniteField=base_ring(P)
  @assert k==parent(c[1])
  R::FqNmodPolyRing=parent(P)
  t::PolyElem{T}=gen(R)
  p::Array{T,1}=fq_nmod[k(coeff(P,j)) for j in 0:m]
  b::Array{T,1}=Array(fq_nmod,n+1) # array filled with "#undef"
  for i in 1:(n+1)
    b[i]=k(0)
  end
  for i in range(m+n,-1,m+n+1)
    for j in range(min(m,i),-1,min(m,i)-max(0,i-n)+1)
      b[i-j+1]=b[i-j+1]+p[j+1]*c[i+1]
    end
  end
  return R(fq_nmod[b[i] for i in 1:(n+1)])
end

"""
    remT{T}(r::Array{T,1},P::PolyElem{T},n::Int64)

Transposition of the remainder by P algorithm.

An other linear extension algorithm. Take the r first values of a linear
recurring sequence of minimal polynomial P and compute the n first values.

# Output
A polynomial which coefficients are the values of the sequence.
"""
function remT{T}(r::Array{T,1},P::PolyElem{T},n::Int64)
  m=degree(P)
  k=base_ring(P)
  @assert k==parent(r[1])
  K=parent(P)
  t=gen(K)
  R=K(fq_nmod[r[i] for i in 1:m])# useless creation of a list... memory !
  α=reverse(P,m+1)
  α=gcdinv(α,t^(n-m+1))[2]
  b=copy(r)
  while length(b)<(n+1)
    push!(b,k(0))
  end
  return R-(t^m)*((α*mulT(b,P,n-m))%(t^(n-m+1)))
end


"""
    remTnaif{T}(r::Array{T,1},P::PolyElem{T},n::Int64)

Linear extension algorithm.

Take the m first elements of a Linear recurring sequence with minimal
polynomial P and compute the n first.
"""
function remTnaif{T}(r::Array{T,1},P::PolyElem{T},n::Int64)
  m=degree(P)
  p=fq_nmod[coeff(P,j) for j in 0:m]
  b=copy(r)
  while length(b)<n
      s=sum([-1*p[j]*b[end-m+j] for j in 1:m])
      push!(b,p[end]^(-1)*s)
  end
  return b
end


"""
    embed{T}(b::Array{T,1},P::PolyElem{T},c::Array{T,1},Q::PolyElem{T},r::Int64=0)

Compute the embeding of Π={bc | b ∈ k[x]/(P) , c ∈ k[y]/(Q)} ⊂ k[x,y]/(P,Q) in k[z]/(R).
"""
function embed{T}(b::Array{T,1},P::PolyElem{T},c::Array{T,1},Q::PolyElem{T},r::Int64=0)
  if r==0
    r=length(b)*length(c)
  end
  t::Array{T,1}=remTnaif(b,P,r)
  u::Array{T,1}=remTnaif(c,Q,r)
  return fq_nmod[t[j]*u[j] for j in 1:r]
end

"""
    berlekampMassey{T <: FieldElem}(a::Array{T,1},n::Int64,S=0)

Compute the minimal polynomial of a linear recurring sequence.
"""
function berlekampMassey{T <: FieldElem}(a::Array{T,1},n::Int64,S=0)
  if S==0
    k::FqNmodFiniteField=parent(a[1])
    S::FqNmodPolyRing,x::PolyElem{T}=PolynomialRing(k,"x")
  else
    x=gen(S)
  end
  m::Int64=2*n-1
  R0::PolyElem{T}=S(x^(2*n))
  R1::PolyElem{T}=S(reverse(a))
  V0::PolyElem{T}=S(0)
  V1::PolyElem{T}=S(1)
  while n<=degree(R1)
    Q::PolyElem{T},R::PolyElem{T}=divrem(R0,R1)
    V::PolyElem{T}=V0-Q*V1
    V0=V1
    V1=V
    R0=R1
    R1=R
  end
  return V1*lead(V1)^(-1)
end

function computeR{polyT}(P::polyT,Q::polyT)
  m::Int64=degree(P)
  n::Int64=degree(Q)
  T=typeof(coeff(P,0))
  k=parent(coeff(P,0))

  vp::Array{T,1}=Array(T,m) # creation of the vector (1,0,...,0) (length m)
  vp[1]=k(1)
  for j in 2:m
    vp[j]=k(0)
  end

  vq::Array{T,1}=Array(T,n) # creation of the vector (1,0,...,0) (length n)
  vq[1]=k(1)
  for j in 2:n
    vq[j]=k(0)
  end

  up=monomialToDual(vp,P)
  uq=monomialToDual(vq,Q)

  t=embed(up,P,uq,Q,2*m*n)

  return berlekampMassey(t,m*n,parent(P))
end

function project(a::Array{fq_nmod,1},P::fq_nmod_poly,Q::fq_nmod_poly)
  n::Int64=degree(Q)
  m::Int64=degree(P)
  c::Array{fq_nmod,1}=Array(fq_nmod,n)
  k=parent(coeff(Q,0))
  c[1]=k(1)
  for j in 2:n
    c[j]=k(0)
  end
  u::Array{fq_nmod,1}=remTnaif(c,Q,m*n)
  println(u)
  K=parent(P)
  d=K([a[j]*u[j] for j in 1:(m*n)])%P
  return fq_nmod[coeff(d,j) for j in 0:(m-1)]
end

### ESPACE DE TESTS ###
